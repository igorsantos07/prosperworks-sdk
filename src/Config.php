<?php

namespace ProsperWorks;

use ProsperWorks\Interfaces\Cache;
use ProsperWorks\Interfaces\Crypt;

/**
 * Holds settings for the ProsperWorks API and related classes.
 * As most entries would need custom instantiation anyway, all methods are getter/setter and use static vars.
 * All of them, except the {@link debugLevel}, only allow a single set, at first usage.
 *
 * @method static string email()       Used for API authentication
 * @method static string token()       Used for API authentication
 * @method static string secret()      Used for webhook security
 * @method static string defaultRoot() Used when no root parameter is given on Webhooks. Default to https://localhost
 * @method static Crypt  crypt()       Used to encrypt and decrypt the webhook secret
 * @method static Cache  cache()       Optional. Used to speeed up meta-data operations, such as contact types.
 */
abstract class Config
{
    /** Spits no debug info */
    const DEBUG_NONE = 0;
    /** Prints the HTTP Verb + URI. Useful to see if requests are happening */
    const DEBUG_BASIC = 1;
    /** Prints HTTP Verb, URI and Payload. "Did I send the request the right way?" */
    const DEBUG_COMPLETE = 2;

    private static $email;
    private static $token;
    private static $secret;
    private static $defaultRoot = 'https://localhost';
    private static $crypt;
    private static $cache;

    /**
     * Sets all config values.
     *
     * Note: we're not typehinting the objects on the signature so the user is free to give a class that has those
     *       methods, but doesn't implement the interface (such as Framework objects), but we still have type completion
     *       across the library.
     *
     * @param string            $email
     * @param string            $token
     * @param string|null       $secret
     * @param string|null       $defaultRoot
     * @param object|Crypt|null $crypt
     * @param object|Cache|null $cache
     */
    public static function set($email, $token, $secret = null, $defaultRoot = null, $crypt = null, $cache = null) {
        self::$email = $email;
        self::$token = $token;
        self::$secret = $secret;
        self::$defaultRoot = $defaultRoot;
        self::$crypt = $crypt;
        self::$cache = $cache;
    }

    /**
     * Gets/sets the debug level.
     * Doesn't do anything by itself, but serves as central repository of the debug flag for
     * the various ProsperWorks scripts.
     * @param int|null $level One of the DEBUG_* constants
     * @return int
     */
    public static function debugLevel(int $level = null): int
    {
        static $value;
        if (!$value) {
            $value = self::DEBUG_NONE;
        }

        if (is_null($level)) {
            return $value;
        } else {
            return $value = $level;
        }
    }

    public static function __callStatic($name, $args) { return isset(self::$$name) ? self::$$name : null; }

    /**
     * Helper function to allow for easy setting cache data if it's not found. Can be skipped by passing $cache=null.
     * @param string   $key      Cache key to search for, or to store after generation
     * @param callable $setter   If the key is not found, how do we generate the data?
     * @param int      $lifetime If given, sets the lifetime for the newly-stored data
     * @return mixed Whatever is found in $cache using $key, or generated by $setter
     */
    public static function cacheGetSet(string $key, callable $setter, int $lifetime = null)
    {
        if (!self::cache()) {
            return $setter();
        }

        $data = self::cache()->get($key);
        if (!$data) {
            $data = $setter();
            self::cache()->save($key, $data, $lifetime);
        }

        return $data;
    }
}
